{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1715744120913391618",
        "title": "Nextjs App Router 模式新能力",
        "description": "Next.js 13 App Router，一种新的前端编程模式，SEO友好的框架",
        "content": "nextjs 13.4 的发布，宣布 App Router 稳定版本的到来，\n\n![image-20231004170531857](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20231004170531857.png)\n\n​\t上图是 next 的下载量，可以看到 **遥遥领先** 其他框架，vercel 公司的新一代 React 框架，为什么如此好用？下面我们看一下 13.4 版本的新功能吧！\n\n### App Router\n\n​\tNext.js 13.4 是第一个将新的应用程序目录和应用程序路由器功能从测试版中剔除的版本！这就代表着 App Router 正式成为稳定版，可以用于生产环境，相比较之前的` pages/` 下文件路由，`App Router`更加的自由，具体优势有：\n\n- 更灵活的路由规则：使用 \"app route\" 可以更自由地定义路由，不再仅依赖于文件的相对路径。这样可以更好地组织和管理路由结构，特别是对于复杂的应用程序而言。\n- 更好的代码分离：在 \"app route\" 中，可以将路由定义和页面逻辑分离到不同的文件或模块中。这样可以提高代码的可读性和可维护性。\n- 更好的代码重用：\"app route\" 支持模块化的路由定义和组合，使得页面的复用更加便利。您可以将一些共享的路由规则封装成模块，便于在不同的页面或应用中共享和复用。\n\napp route 使 Next 的开发体验变得更好，此外，Next.js 文档站点进行了重大更新，将 App Router 设为默认值，这也许象征着此版本的重要性！您现在可以在新的 App Router 和之前的 Pages Router 之间切换文档。\n\n![image-20231005165320746](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20231005165320746.png)\n\n#### App 文件下的路由\n\n新应用程序目录中的路由就像添加导出 React 函数组件的 `page.tsx` 文件一样简单。应用程序的路由由应用程序目录中文件夹的层次结构定义。例如，在 `/` 路由上创建页面就像在应用程序目录的根目录中添加 page.tsx 文件一样简单\n\n##### 1）新的路由规范\n\n接下来，让我们展示如何使用新的应用程序路由器创建更复杂的应用程序路由：\n\n![image-20231007124732252](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20231007124732252.png)\n\n正如您在上面看到的，我们能够创建一个简单的路由，例如 `/about` ，以及使用 Next.js 的动态路由创建更复杂的路由，例如 `/articles/article/12345` 。\n\n新的路由规范通过为布局、页面、模板等强制使用特殊文件名，解决了之前版本中所有文件都作为路由，无法在`pages/` 下声明不作为路由的文件，使开发体验变得更好。\n\n##### 2）获取数据方式更简洁\n\n借助新的 App Router，我们的页面可以使用 React Server 组件，这使我们能够使用熟悉的 async/await 语法来简化数据获取。\n\n```tsx\n// app/page.tsx\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/...');\n  const data = res.json();\n  return '...';\n}\n```\n\n在 12 的时候，我们想要获取数据需要：\n\n```tsx\n// pages/example.js\n\nimport React from 'react';\n\nexport async function getServerSideProps() {\n  // 在此处获取服务端数据\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  \n  return {\n    props: {\n      data // 将数据作为 props 返回\n    }\n  };\n}\n\nfunction Example({ data }) {\n  // 在客户端使用获取到的数据进行渲染\n  return (\n    <div>\n      <h1>Server-side rendering example</h1>\n      <p>{data}</p>\n    </div>\n  );\n}\n\nexport default Example;\n```\n\n相比较更加符合之前的开发习惯！\n\n##### 3）新的概念：服务器组件\n\n在 Next.js 13 中，**文件默认是服务器组件**。您可以通过在模块顶部包含 `'use client'` 指令来选择使用客户端组件。如果您还不了解客户端组件 和 服务器组件的区别，强烈推荐文章：[理解React服务器组件](https://www.joshwcomeau.com/react/server-components/)，这篇文章详细解释了为什么需要引入新的概念：服务器组件，以及客户端组件和服务端组件的边界问题，开发中容易混淆的概念等等，非常值得一看\n\n##### 4）路由段配置\n\n我们的页面还可以导出路由段，使我们能够控制页面的渲染方式。 Next.js 中的一种常见做法是静态生成页面。但是，当我们使用动态参数时，我们遇到了一个问题，Next.js 如何知道要静态生成哪些页面？我们可以利用 `generateStaticParams` 来解决这个问题。这在做 seo 中非常有用\n\n```tsx\n// app/articles/article/[id]/page.tsx\ntype ArticleProps = Pick<Article, 'id'>\n\nexport default async function Page({ id }: ArticleProps) {\n  const article = await(await fetchArticleById(id)).json();\n  return <BlogArticle article={article} />\n}\n\nexport async function generateStaticParams(): ArticleProps[] {\n  const articles = await(await fetchArticles()).json();\n  return articles.map(article => ({ id: article.id }))\n}\n```\n\n\n\n在上面的示例中，我们导出一个名为 `generateStaticParams` 的异步函数，该函数加载我们的所有博客文章并返回一个对象数组，该数组的属性与动态路线段的名称相匹配，在本例中为 `id` 。 Next.js 将使用它为我们的每篇博客文章静态生成页面。\n\n##### 5）路由段配置\n\nNext.js 13 为我们提供了几个[路由段配置](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config)选项来控制 Next.js 渲染页面的方式。除了 `generateStaticParams` 之外，最常用的路线段配置是 `revalidate` 。当与静态站点生成 (SSG) 结合使用时，重新验证允许您控制页面重新生成的频率。例如我在 page.tsx | route.ts | layout.ts 中，添加如下代码：\n\n```tsx\nexport const revalidate = 60\n```\n\n那么我们的当前页面就会每 60 秒重建一次页面，请注意，它比这更微妙，因此请务必阅读 Next.js 文档网站上的 ISR\n\n我们还可以通过使用 dynamicParams 路由段配置来告诉 next.js 不要渲染 `generateStaticParams` 中未返回的 ID 的页面，\n\n如果我们有一个使用查询参数的页面，我们可能希望在使用动态路由段请求该页面时动态服务器呈现它，那么我们可以根据我们的用例强制页面静态或动态生成\n\n```tsx\nexport dynamic = 'force-dynamic'\n// or: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n```\n\n##### 6）布局和模版\n\n**布局**\n\n除了页面之外，Next.js 13 还引入了**布局**和**模板**的特殊文件。在上面的示例中，您可能已经注意到，我们在文件夹层次结构的各个级别包含了多个 `layout.tsx` 文件。我们创建了一个根级 `layout.tsx`，这是 Next.js 13 中的典型做法。\n\n在根布局中，我们可以创建 HTML 文档，向头部添加脚本和其他内容，提供语义结构，并将应用程序包裹在供应器中。我们不再需要使用 Next.js 早期版本中的特殊 `<Head>` 和 `<Script>` 组件。我们也可以在这里添加**元数据**，\n\n请注意，`layout.tsx` 和`page.tsx`通常应该是服务器组件，因为我们应该让布局组件在服务器渲染，这样用户可以下载更少的 js，让用户更快看到一些内容。\n\n```tsx\n// app/layout.tsx\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <script>//...</script>\n      </head>\n      <body>\n        <main>\n           <AppProvider>{children}</AppProvider>\n        </main>      \n      </body>\n    </html>\n  );\n}\n\n// app/page.tsx\nexport default function Page() {\n  return //...;\n}\n```\n\n我们还可以在应用程序目录层次结构的每个级别添加布局文件，以将更具体的布局应用于应用程序的不同部分。例如，假设我们想要围绕我们的博客文章添加一个特定的 AppWrapper。我们可以将新的 `layout.tsx` 文件添加到 `page.tsx` 文件旁边的 `/app/articles/article/[id]` 目录中。\n\n```tsx\n// app/articles/article/[id]/layout.tsx\nexport default function RootLayout({ children }) {\n  return (\n    <AppWrapper>{children}</AppWrapper>\n  );\n}\n```\n\n**模版**\n\n模版和布局类似，但是区别在于，模版在不同路由之间切换的时候，模版的内容是销毁和重新新建，但是布局是对应路由下 共享这个 DOM 元素，路由切换不会销毁再新建DOM，\n\n更多请看：[路由之排版](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#templates)\n\n#### 自动代码分割\n\nNext.js 13.4 让**代码分割**和**动态加载内容**变得比以往更容易。在 之前版本中，您必须使用 `next/dynamic` 。现在，整个应用程序可以通过使用 `Suspense` 选择代码分割和动态加载。事实上，您可以在客户端组件中使用简单的条件进行代码分割。查看 Next.js 博客中的以下示例，该示例根据用户是否登录返回完全不同的包：\n\n```tsx\n// app/layout.tsx\nimport { getUser } from './auth';\nimport { Dashboard, Landing } from './components';\n\nexport default async function Layout() {\n  const isLoggedIn = await getUser();\n  return isLoggedIn ? <Dashboard /> : <Landing />;\n}\n```\n\n#### BETA 功能\n\n##### 1）服务器操作\n\nNext.js 13.4 引入了服务器操作（目前处于 alpha 版本），它为您的应用程序带来了更多的灵活性和强大功能。服务器操作允许您直接在应用程序中处理服务器端逻辑，例如获取数据或与 API 交互。此功能不仅简化了您的应用程序架构，还使您能够创建更快、更高效的应用程序。\n\n##### 2）Turbopack\n\n随着 Next.js 13.4 的发布，Turbopack 已进入测试阶段，提供功能更完整、更稳定的体验。 Turbopack 是 Next.js 基于 Rust 的新捆绑器，旨在加速开发中的本地迭代以及很快的生产构建。由于社区在测试和报告错误方面的支持，Turbopack 的采用率不断提高，为未来更快、更高效的开发体验铺平了道路。\n\n##### 3）草稿模式：轻松获取和渲染草稿内容\n\nNext.js 13.4 引入了[草稿模式](https://nextjs.org/docs/app/building-your-application/configuring/draft-mode)，该功能允许您轻松地从无头 CMS 中获取和渲染草稿内容。与现有的预览模式 API 相比，草稿模式提供了更简化和增强的体验，新应用程序目录不支持现有预览模式 API。\n\n通过草稿模式，您现在可以在发布内容之前无缝预览和迭代内容，确保为用户提供最高质量的输出。\n\n什么是 CMS ？\n\n答：CMS 是 Content Management System（内容管理系统）的缩写。它是一种应用程序或一组相关的应用程序，用于创建、管理、分发、发布和更新内容。CMS 提供了一个集中化的仓库，使得你可以在其中收集，管理和发布信息。\n\n在前端开发的上下文中，CMS 通常会提供 API（如 RESTful 或 GraphQL API），前端应用则通过这些 API 与 CMS 进行交互，获取或修改数据。而 CMS 的内容通常包括了网页的文本、图片、视频等。\n\n有许多常见的 CMS，例如 Wordpress, Drupal, Joomla 等等。近年来，所谓的 \"headless CMS\" 也变得越来越流行，例如 Contentful, Prismic, Strapi 等。所谓 \"headless\"，是指在 CMS 不再负责内容的呈现，只通过 API 提供内容，因此可以更灵活地与各种前端框架和技术（例如React，Vue，Angular，或者静态网站生成器）结合使用。\n\n## 总结\n\n个人觉得 Next.js 是一种新的前端开发范式，通过使用 Next.js 13 ,学习到了很多新的概念，同时也觉得使用 Next.js 开发，没有之前流畅，需要学习的还有很多",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/txMz8DLl-nextjs13.4.webp",
        "language": null,
        "viewNum": 8,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-21T14:57:30.000+00:00",
        "updateTime": "2023-10-24T10:09:17.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 12,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-10-11T01:17:28.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "框架"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1714611420164911105",
        "title": "Spring-Security 实现RBAC 权限控制系统",
        "description": "总结",
        "content": "- #### 为什么需要使用权限管理框架?\n\n```java\n1.根据角色实现用户访问控制的实现逻辑基本一致,但开发的时候实现复杂,步骤重复\n2.简化开发步骤,实现相同代码逻辑快速开发让\n```\n\n- #### 常用的权限管理框架有哪些?\n\n  - Shrio  小型企业\n  - Security 中,大型企业\n\n\n\n- #### Security的基本原理是什么?\n\n  ```java\n  1.在用户请求进入tomcat 后 进入dispatcherServlet之前做预处理(过滤器)\n  2.Security的本质是实现了多个多个过滤器,在每个用户的请求做链式逻辑判断,一旦不符合中间某一个过滤器逻辑,就会被拦截\n  3.对未登录的用户拦截,并返回一个页面让其登录,进入loadUserByUsername()方法中逻辑处理\n  4.对登陆的用户保存serssion \n  5.记住我:将用户信息存入cookie 返回前端浏览器\n  6.CSRF :仿跨站伪造请求 钓鱼网站恶意获取用户信息,伪造正常用户发送请求,第一次访问时响应tooken,用户登陆时将tooken 提交\n  ```\n\n- #### 实际开发中,用户的信息从哪里来?\n\n  ```java\n  1.第一次登录时,根据用户传过来的用户名和密码,从mysql中拿取数据\n  2.登陆过,前端传过来cookie,根据cookie信息从redis 中拿取数据\n  ```\n\n- #### Security中如何实现密码加密?\n\n  ```\n  使用BCryptPasswordEncoder().encode();方法对明文密码使用Bcrypt加密方式加密\n  ```\n\n- #### 记住我的原理是什么?\n\n  ```java\n  记住我:将用户信息存入cookie 返回前端浏览器\n  ```\n\n- #### 什么是CSRF? 解决方案有哪些?\n\n  ```jav\n  1.验证 Referer域 是否是服务端自己认可的域名\n  2.第一次访问时响应tooken,用户登陆时将tooken 提交\n  ```\n\n- #### 获取用户认证信息\n\n  ```java\n  SecurityContextHolder.getContext().getAuthentication().getPrincipal()\n  ```\n\n## RBAC系统集成Security\n### Security的授权方式有哪些?如何使用?\n\n- 在配置类中定义哪个用户具有哪些角色或权限。\n- 在Controller的方法或类上贴上Security提供的注解(配置类需要启用注解@EnableGlobalMethodSecurity)\n\n### 如何处理没有权限时的异常?\n\n当用户没有权限时，Spring Security会抛出AccessDeniedException。\nSecurity 默认返回一个403视图页面,我们可以实现AccessDeniedHandler口自定义处理方式,通常返回Json 数据\n自定义的AccessDeniedException异常处理方式需要在security的配置类中添加:调用http.exceptionHandling()\n.accessDeniedHandler();\n\n### 用户的数据从哪里来?如何实现?\n\n- 用户数据来自数据库。\n- 实现UserDetailsService接口来加载用户数据。\n\n### 在项目中,如何获取到登录的员工信息?\n\n使用SecurityContextHolder来获取登录的员工信息，如用户名、角色等。\n\n### 认证器的作用是什么?如何使用认证器?\n\n- 认证器用于验证用户身份\n- 从上下文从获取用户信息再根据访问提供的用户明和密码作比较.\n\n\n### EmployeeServiceImpl中如何实现登录认证?\n\n1. 从Controller中接受到用户名和密码,然后将信息封装到UsernamePasswordAuthenticationToken中\n2. 调用认证器authenticationManager.authenticate()方法将Token对象传入认证\n3. 然后调用authenticate.getPrincipal()方法,获取用户信息,并存入Redis中\n4. 前提authenticate.getPrincipal()方法拿到的必须是UserDetails的实现类,且有对应登录的实体类属性.\n\n### Security如何检查用户是否有登录?\n\n1. 可以使用SecurityContextHolder.getContext().getAuthentication()来获取认证信息。\n2. 在自定义过滤器中判断用户是否传入Token,如果有就去Redis中获取对应的用户信息\n3. 将获取到的用户信息封装到UsernamePasswordAuthenticationToken中\n4. 后续过滤器等其他组件会先判断Security上下文是否有用户信息,有信息代表登录了.\n5. 自定义过滤器需要在其他过滤器可能会需要从Security上下文获取用户信息的前面执行,否则后面的过滤器链拿不到用户信息.\n\n### 在什么时候将用户的认证信息存储起来?\n\n用户的认证信息在登录时存储起来，认证成功后，Security会创建Authentication对象并存储在SecurityContext中。\n\n### 为什么需要调整过滤器的顺序?\n\n- 调整过滤器的顺序可以确保请求按照正确的顺序通过过滤器链。\n- 其他过滤器可能会需要从Security上下文获取用户信息,存入用户信息的过滤器如果不前面执行,后面的过滤器链拿不到用户信息.\n\n### Security从哪里获取用户的权限? 如何将用户的权限告知Security?\n\n- 用户的权限通常来自配置或数据库中的角色/权限信息。\n- 通过注解方式/配置类方式标识资源的权限\n- 通过UserDetails的实现类去获取用户的权限信息,并在自定义过滤器中存入Security的上下文中\n\n### 如何描述接口需要什么权限或者角色?\n\n- 在配置类中使用AntMatchers方法分配权限或角色\n- @PreAuthorize注解来描述接口需要的权限或角色。\n\n### 如何处理认证和授权失败的异常?\n\n- 自定义异常处理器\n- 配置Spring Security的异常处理来处理认证和授权失败的异常，通常会返回状态码和错误信息(Json)\n  \n  \n![image.png](https://pic.code-nav.cn/post_picture/1673111457186713601/fQNrKxSA-image.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 39,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-18T11:56:33.000+00:00",
        "updateTime": "2023-10-24T14:17:46.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it😣😣",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-21T02:01:28.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712670027519488002",
        "title": "RBAC 基础 -权限控制",
        "description": null,
        "content": "## RBAC 角色权限控制\n\n### 1. 什么是 RBAC\n\nRBAC（Role-Based Access Control，基于角色的访问控制），是一种新的访问控制机制，\n它是以角色为中心来进行访问控制的，即用户通过角色与权限进行关联，进而获得权限，从而访问系统资源。\n\n#### 什么是ABAC(扩展--->框架少,实现比较困难,开发成本高,但一旦实现,可以实现很多复杂的控制)\n\nABAC（Attribute-Based Access Control，基于属性的访问控制），是一种新的访问控制机制，\n它是以属性为中心来进行访问控制的，即用户通过属性与权限进行关联，进而获得权限，从而访问系统资源。\n\n\n### 2. RBAC 的优点\n\nRBAC 的优点主要有以下几点：\n\n- 降低了复杂性：\n- 降低了维护成本\n- 降低了风险：\n- 降低了开发成本\n- 降低了运维成本\n- 降低了安全风险\n- 降低了系统复杂度\n- 降低了系统的耦合度\n- 降低了系统的依赖性\n\n### 3. RBAC 的分级\n- RBAC0：基本的RBAC模型，只有用户、角色、权限三个基本元素，是最简单的RBAC模型。\n- RBAC1：在RBAC0的基础上增加了角色继承，即角色可以继承其他角色的权限。\n- RBAC2：在RBAC1的基础上增加了用户-角色绑定，即用户可以绑定多个角色。\n- RBAC3：在RBAC2的基础上增加了约束，即角色可以绑定多个用户，但是每个用户对于某个角色的绑定都有时间上的限制。\n\n\n### 3. RABC 的核心\n\n- 用户（User）：用户是指系统的使用者，可以是一个人，也可以是一台机器，或者其他什么东西。\n- 角色（Role）：角色是指用户的职责或者角色，一个用户可以有多个角色，一个角色可以包含多个用户。\n- 权限（Permission）：权限是指用户在某个角色上可以执行的操作，一个角色可以包含多个权限，一个权限可以包含多个角色。\n- 资源（Resource）：资源是指用户可以访问的系统资源，比如文件、目录、数据库等。\n- 操作（Operation）：操作是指用户对资源可以执行的操作，比如读、写、执行等。\n- 会话（Session）：会话是指用户在一段时间内的访问，一般来说，用户登录系统后，就会建立一个会话，直到用户退出系统，这个过程就是一个会话。\n- 会话管理（Session Management）：会话管理是指对用户的会话进行管理，包括建立会话、维护会话、销毁会话等。\n- 会话控制（Session Control）：会话控制是指对用户的会话进行控制，包括会话的访问控制、会话的权限控制等。\n- 会话访问控制（Session Access Control）：会话访问控制是指对用户的会话进行访问控制，包括会话的访问控制、会话的权限控制等。\n- 会话权限控制（Session Permission Control）：会话权限控制是指对用户的会话进行权限控制，包括会话的访问控制、会话的权限控制等。\n- 会话权限管理（Session Permission Management）：会话权限管理是指对用户的会话进行权限管理，包括会话的访问控制、会话的权限控制等。\n- 会话权限分配（Session Permission Assignment）：会话权限分配是指对用户的会话进行权限分配，包括会话的访问控制、会话的权限控制等。\n\n# 4. RBAC 的实现\n## RBAC 系统\n\n### 1. 基于角色控制资源访问\n\n### 2. 数据库表设计 :\n\n### 用户表--->用户角色中间--->角色表--->角色资源中间表--->资源表\n\n### 3. 前后端构建\n\n##### 1.1 基于Vue 快速构建 \n\n##### 1.2 使用Element-Ui 快速渲染页面布局\n\n##### 1.3 spring-boot 快速构建web 项目\n\n\n\n### 4. 前后端数据交互\n\n###### 1.1.1 构建表格页面\n\n- ##### 基本CURD 的数据交互\n\n###### 1.2.2 基本实现分页数据展示--->获取当前分页条的数据--->发送Axios请求 拿去分页数据\n\n###### ---> 后端接搜数据 ---> 查询全部信息(涉及时间的字段使用@JsonFromat(....)),通过分页插件PageHelper,将list集合封装到PageInfo中,返回JsonResult \n\n###### 1.2.2 实现基本删除 ----->点击删除按钮,通过插槽 scope,获取到当前行的数据---> 发送Axios 请求 --->后端接受到当前行的id(主键iD)-->执行删除SQL 语句\n\n\n\n###### 1.2.3 实现批量删除的方法 ---> 勾选时,给定状态,当点击批量删除时,遍历该状态的行,拿去取主键ID存入集合,发送Psot请求,将数组通过qs.tistringify方法(设置不需要数组索引)将书据转换成json格式,设置发送方式将数据转换成表单(www---???),----> 后端接受数据List<>,或数组都可以(使用@RequestParam 接收)--->拿到数组,执行SQL语句,通过动态SQL 遍历传过来的数组,执行数据的删除.\n\n###### 1.2.3 实现新增功能 -->点击新增按钮弹出新增表单,输入数据,点击提交时--->发送Axios请求,将表单数据提交到后端处理-->后端拿到对应的实体类对象数据--->执行新增SQL语句(设置时间可以使用NOW() )\n\n\n\n###### 1.2.4 实现并编辑功能-->点击编辑,回显数据,拿到当前行的全部数据-->发送Axios请求把实体类对象传入后端--->后端接受参数,执行修改的SQL语句(动态SQL if 判断字段)\n\n\n\n\n\n###### 1.2.5 在分页功能的基础上增加过滤查询,动态sql 判断\n\n- #### 树形结构数据\n\n  ##### 1.1 动态菜单查询\n\n  ###### 1.1.1 遍历 \n\n  ```java\n  1. 思路: 遍历方式用于获取树形结构数据中的每一个节点，通常使用迭代方法来实现。\n  \n  2. 代码逻辑:\n     - 初始化一个队列或栈，将根节点加入其中。\n     - 进入循环，直到队列或栈为空。\n     - 在每次迭代中，弹出队列或栈中的一个节点，处理它的数据。\n     - 如果节点有子节点，将子节点加入队列或栈，以便后续处理。\n  ```\n\n  \n\n  ###### 1.1.2 递归调用\n\n  ```java\n  1. 思路: 递归方式用于获取树形结构数据中的每一个节点，通常使用递归方法来实现。\n  \n  2. 代码逻辑:\n     - 创建一个递归函数，接受当前节点作为参数。\n     - 在递归函数中，处理当前节点的数据。\n     - 如果当前节点有子节点，对每个子节点调用递归函数。\n     - 递归会一直深入子节点，直到到达叶子节点。\n  \n  ```\n\n  \n\n  ###### 1.1.3 sqL 语句\n\n  ```sql\n  <!-- 循环的 SQL -->\n  SELECT * FROM menu WHERE parent_id = 0; -- 获取根节点\n  \n  <!-- 递归的 SQL -->\n  WITH RECURSIVE MenuTree AS (\n      SELECT * FROM menu WHERE parent_id = 0 -- 获取根节点\n      UNION ALL\n      SELECT m.* FROM menu m\n      INNER JOIN MenuTree mt ON m.parent_id = mt.id\n  )\n  SELECT * FROM MenuTree;\n  -- 递归查询的 SQL 使用了公共表达式（CTE）和 UNION ALL，以获取所有层级的子菜单。\n  \n  ```\n\n- ##### 穿梭框 数据交互 查询  分配角色--->用户_角色表\n\n  ###### 1.1 前端页面\n\n  ###### 1.2 拿取所有角色\n\n  ###### 1.3 通过分配按钮拿去当前用户id 查询所拥有的角色\n\n  ###### 1.4 判断用户是否更改过穿梭框的数据,校验是否有数据---有--->拿到当前表数据,发送请求--->后端接受请求获取参数-->拿到 用户ID 先执行删除角色的Sql --->删除成功后新增角色数据(先删后改--->保证事务的一致性)\n\n  \n\n- #####   角色分配权限  角色表_权限中间表 -->权限表\n\n  ###### 0 --> 页面加载时获取 所有权限\n\n  ###### 1.1 前端点击分配按钮 --->弹出表单数据\n\n  ###### 1.2 发送 请求查询当前拥有的权限--->SQL 查询-->回显数据\n\n  ###### 1.3 修改后提交--->拿到表单数据,发送请求--->后端接受请求获取参数,拿到 角色ID 先执行删除已有权限的Sql --->删除成功后新增表单权限数据(先删后改--->保证事务的一致性)\n\n- ##### 登陆相关权限验证\n\n  - ###### 登录\n\n    1.前端页面提交表单数据--->发送请求\n\n    2.后端接受请求,检查数据是否正常\n\n    3.正常:查询SQL 拿取对应的user信息,判断数据是否和前端传过来的一致\n\n    4:一致:用UUID生成Token,调用Spring-boot中Redis(RedisTemplate.opsForValue().set())方法,以Token为key,对象为value存入Redis中(对应实体类应支持序列化)\n\n    5.返回Token\n\n    6.前端接受数据,VueX将数据存入请求头\n\n    7.立即调用Info 方法,根据Token获取对应的用户信息\n\n  - ###### 获取信息\n\n    1.VueX调用Info 方法,根据Vuex中存入的Token获取对应的用户信息\n\n    2.后端接受请求,从请求头中获取Token(@RequestHeader)\n\n    3.校验数据,有没有传Token,有,判断Token是否有效\n\n    4.从Redis中获取用户信息(RedisTemplate.opsForValue().get())\n\n    5.将数据返还后端\n\n  - ###### 登出\n\n    1.  点击退出登录按钮发送登出请求\n    1.  后端接受到请求,从请求头中获取Token\n    1.  拿到Token,调用RedisTemplate.delet()方法\n    1.  返回成功的状态信息\n    1.  前端Vuex接受成功响应,从前端重置Token,刷新页面\n\n\n#### 5.请求拦截器 \n\n- ##### 判断登录请求拦截器\n\n  1.自定义登录拦截器,继承HandlerInterceptorAdapter或实现HandlerInterceptor   (交给容器管理)\n\n  2.实现preHandle\n\n  3.逻辑判断处理\n\n  ```java\n  1.获取请求头中的Token\n  2.根据Token去Redis中查询对应的用户信息\n  3.有信息,放行  没有拦截\n  ```\n\n  4.将自定义拦截器注册到Spring-Mvc 中\n\n  5.编写 WebMvcConfigurer 配置类,实现\n\n  ```java\n  // 注册拦截器\n          registry.addInterceptor(checkLoginInterceptor) // 将自定义拦截器注入到mvc中\n                  .addPathPatterns(\"/**\") // 设置需要拦截的路径 /** 表示拦截所有请求\n                  .excludePathPatterns(\"/users/login\"); // 设置排除的路径 登录请求不需要拦截\n  ```\n\n  \n\n- ##### 访问资源权限请求拦截器\n\n  1.定义注解,贴在方法上来解释该方法请求的资源对应需要的权限\n\n  2.自定义拦截器\n\n  3.逻辑判断处理\n\n  ​\t3.1 是否是超级管理员权限\n\n    ```java\n    1.获取请求头中的Token\n    2.根据Token去Redis中查询对应的用户信息\n    3.是管理员,可以访问所有路径,放行\n    ```\n\n​\t\t\t3.2 判断用户访问的资源是否需要权限\n\n```java\n1.获取访问资源的路径方法\nHandlerMethod handlerMethod = (HandlerMethod) handler;\n2获取方法上的注解\nhandlerMethod.getMethodAnnotation(RequiredPermission.class); //传入自定义注解字节码通过反射获取value值\n3.如果拿不到该注解,说明不需要权限,直接放行\n```\n\n​\t\t\t3.3 判断该用户是否具有该注解的对应数据\n\n```java\n1.通过用户id  关联 用户和角色中间表 \n2.再通过角色id 关联 角色和权限中间表\n3.再同过权限id 查询 对应的权限表达式\n4. 一个用户可能会有多个权限 ,且权限可能重复(去重)\n5.拿到权限表达式集合判断是否包含当前访问资源的权限\n6.有.放行   没有 : 拦截\n```\n\n![image-20231017224134744](C:\\Users\\33960\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231017224134744.png)\n\n### 6. 优化逻辑\n\n- ##### 常量类抽取:   对常用字符串,数字等抽取\n\n- ##### 自定义异常:在代码中,如出现逻辑判断会抛出一些异常,如果用RuntimeException(),Exception都会难以快速定位\n\n- ##### 统一异常处理:将异常统一处理不用在可能出现异常的代码上都使用tar catch 包围,还可以指定自定义异常的处理方式\n\n- ##### 方法抽取:将一些多次使用的代码抽离出来定义成工具类,增加复用性\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 35,
        "thumbNum": 4,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T03:22:09.000+00:00",
        "updateTime": "2023-10-24T02:29:24.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it😣😣",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-21T02:01:28.000+00:00"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712664270979854337",
        "title": "NoSqol-Redis 基础",
        "description": "NoSql -Redis",
        "content": "## NoSql\n\n### 什么是NoSQL\n- NoSQL(Not only SQL):不仅仅是Sql,是对不同于传统的关系数据库(以二维表结构展示)的数据库管理系统的统称\n- NoSql 与Sql 之间不是对立关系,而是作为Sql的补充,满足在特殊需求上,Sql实现复杂,效率低等问题...\n\n### 常见类型的NoSql\n\n- 键值数据库 以 key-value 的形式存储数据  -->Redis\n- 文档数据库 以Document的形式存储  --->MongoDB,Elasticsearch\n- 图类型数据库 图结构  --->Neo4J\n- 列族数据库 以列族式存储，将同一列数据存在一起 -->HBase\n\n 扩展:\n \n     1 .https://blog.csdn.net/weixin_44259720/article/details/104839050\n     2. https://zhuanlan.zhihu.com/p/345342966\n## Redis\n\n### 什么是Redis\n- 以 key-value 形式存储,和传统的关系型数据库不一样.不一定遵循传统数据库的一些基本要求.(非关系型的,分布式的,开源的,水平可拓展的)\n\n- Redis 是以 key-value store 存储.\n        \n        键可以包含:(string)字符串,哈希,(list)链表,(set)集合,(zset)有序集合.\n        这些数据集合都指出push/pop,add/remove及取交集和并集以及更丰富的操作.\n        redis支持各种不同方式排序,为了保证效率,数据都是缓存在内存中.\n        它可以从周期性的把更新的数据写入到磁盘或者把修改操作写入追加的文件中.\n### 优缺点\n\n\n- 优点:\n\n```text\n高并发读写\n海量数据的高效率存储和访问\n数据的可拓展性和高可用性\n单线程操作,每个操作都是原子操作,没有并发相关问题\n```\n\n- 缺点:\n```text\n事务处理非常简单\n无法做太复杂的关系数据库模型\n基于内存容易丢失数据\n```\n\n### 使用场景\n\n#### 缓存中间件\n\n- Redis 缓存的优缺点\n```text\n\t优点\n\t\t提高查询性能, 减少 IO 操作\n\t\t减轻 MySQL 数据库负担\n\t\t减轻应用服务器 cpu & 内存负担\n\t缺点\n\t\t数据一致性问题\n\t\t可能丢失数据\n```\n- 什么数据适合做缓存?\n```text\n\t查询频率高\n\t修改频率低\n\t一致性要求较低\n```\n- 缓存操作流程\n```text\n\t1. 读取 redis 数据，有则直接返回\n\t2. redis 中没有，查询 mysql 数据库\n\t3. 将 mysql 数据库的数据存储到 redis\n\t4. 返回该数据\n```\n\n### NoSql\n\n- NoSQL 应用场景\n 1. 数据频繁更新且一致性要求不高\n \n\t\t阅读数/评论数/分享数等\n\t\t接口限流\n2. 基于 List 实现栈/队列等特殊结构\n3. 基于经纬度的地理位置操作--->Redis GEO\n\n\n\n\n\n\n# 常见命令和基本五大数据类型\n \n### 全局命令\n\n| 命令               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `PING`             | 测试连接是否正常                                             |\n| `INFO`             | 获取服务器信息                                               |\n| `FLUSHALL`         | 删除所有数据库的所有数据                                     |\n| `FLUSHDB`          | 删除当前数据库的所有数据                                     |\n| `SELECT`           | 选择数据库                                                   |\n| `AUTH`             | 使用密码进行认证                                             |\n| `KEYS`             | 查找所有符合给定模式的键                                     |\n| `EXPIRE`           | 设置键的过期时间                                             |\n| `TTL`              | 获取键的剩余过期时间                                         |\n| `DEL`              | 删除键                                                       |\n| `RENAME`           | 重命名键                                                     |\n| `DBSIZE`           | 获取当前数据库中键的数量                                     |\n| `SCAN`             | 迭代数据库中的键                                             |\n| `EVAL`             | 执行Lua脚本                                                  |\n| `SCRIPT LOAD`      | 加载Lua脚本                                                  |\n| `SCRIPT EXECUTE`   | 执行已加载的Lua脚本                                          |\n| exists key         | 判断 key 是否存在, 返回 1 或 0, 1表示存在, 0表示不存在       |\n| ttl key            | 返回指定 key 还有多少秒过期, 如果已经过期或者不存在, 返回 -2, 如果没有设置过期时间, 返回 -1 |\n| expire key seconds | 为指定 key 设置过期时间为 seconds 秒, 如果之前已经设置了过期时间, 会直接覆盖之前的 |\n| flushdb            | 清除 redis                                                   |\n| keys pattern       | 按照指定格式扫描所有 key, 返回匹配的 key 集合                |\n\n### 常用数据类型命令\n\n### String\n\n| 命令                  | 描述                                             |\n|----------------------|--------------------------------------------------|\n| `SET key value`      | 存储一个键值对                                    |\n| `GET key`            | 获取指定键的值                                    |\n| `INCR key`           | 原子性地将键的值加1                               |\n| `DECR key`           | 原子性地将键的值减1                               |\n| `INCRBY key value`   | 原子性地将键的值增加指定值                        |\n| `DECRBY key value`   | 原子性地将键的值减少指定值                        |\n| `SETEX key seconds value` | 设置键值对的同时，设置过期时间               |\n| `SETNX key value`    | 如果键不存在则设置，返回1；如果键已存在则不设置，返回0（原子性操作） |\n| `MSET key1 value1...keyn valuen` | 设置多个键值对  |\n| `MGET key1 key2 keyn` | 获取多个指定键的值                             |\n\n#### 应用场景\n\n- 计数器（如浏览数、评论数、点赞数等）\n- 分布式自增ID生成器\n- 共享Session\n\n### Hash\n\n| 命令                          | 描述                                            |\n|------------------------------|-------------------------------------------------|\n| `HSET key field value`       | 存储一个键值对到hash结构，键名为key，字段为field，值为value |\n| `HGET key field`             | 获取指定hash结构中field的值                     |\n| `HKEYS key`                  | 获取hash结构下指定key的所有字段名                  |\n| `HVALS key`                  | 获取hash结构下指定key的所有字段值                  |\n| `HINCRBY key field value`    | 原子性地将指定hash结构key中的field增加value（field必须是数字） |\n| `HGETALL key`                | 一次性返回指定hash key中的所有键值对              |\n\n#### 应用场景\n\n- 存储复杂类型的属性\n- 减少外部键数量，通过hash对数据进行分类，将同一分类下的数据存储在hash中\n\n\n\n\n\n### List\n\n| 命令                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| `RPUSH key value...`    | 往列表（List）的最后添加一个或多个元素                       |\n| `LINDEX key index`      | 获取列表中指定索引位置的元素                                 |\n| `LRANGE key start stop` | 获取列表中从指定的 start 索引到 stop 索引位置范围内的所有元素 |\n| `LLEN key`              | 返回列表中的元素个数                                         |\n| `LREM key count value`  | 删除列表中指定值为 value 的元素                              |\n|                         | - count > 0：从头到尾删除 count 个元素                       |\n|                         | - count < 0：从尾到头删除 count 个元素                       |\n|                         | - count = 0：删除所有值为 value 的元素                       |\n| `LPUSH`/`RPOP`          | 用于实现队列，支持先进先出（FIFO）                           |\n| `LPUSH`/`BRPOP`         | 用于实现阻塞队列，支持先进先出（FIFO），在获取不到元素时线程会阻塞等待 |\n| `LPUSH`/`LPOP`          | 用于实现栈，支持先进后出（LIFO）                             |\n\n#### 应用场景\n\n- 用作各种列表类型的数据结构\n  - 普通列表\n  - 队列/阻塞队列\n  - 栈\n- 关注人集合/粉丝集合/收藏文章集合等\n  - 注意处理大键（Key）的情况\n\n\n\n\n\n### Set\n\n| 命令                    | 描述                                           |\n| ----------------------- | ---------------------------------------------- |\n| `SADD key members...`   | 往集合（Set）中添加一个或多个成员              |\n| `SCARD key`             | 返回集合中的成员数量                           |\n| `SMEMBERS key`          | 返回集合中的所有成员                           |\n| `SDIFF key1 key2`       | 返回两个集合 key1 和 key2 的差集               |\n| `SINTER key1 key2`      | 返回两个集合 key1 和 key2 的交集               |\n| `SUNION key1 key2`      | 返回两个集合 key1 和 key2 的并集               |\n| `SPOP key count`        | 随机移除并返回集合 key 中的 count 个成员       |\n| `SRANDMEMBER key count` | 随机返回集合 key 中的 count 个成员（允许重复） |\n\n#### 应用场景\n\n- 求交集、并集、差集的需求\n- 数据去重、获取随机数\n- 抽奖功能等\n\n\n\n### Sorted Set 类型(ZSet)\n\n| 命令                                 | 描述                                                   |\n| ------------------------------------ | ------------------------------------------------------ |\n| `ZADD key score value`               | 往有序集合（ZSet）中添加一个带有分数的成员             |\n| `ZCARD key`                          | 返回有序集合中的成员数量                               |\n| `ZCOUNT key min max`                 | 返回有序集合中分数在 min 和 max 之间的成员数量         |\n| `ZINCRBY key score value`            | 为有序集合中的指定成员增加分数                         |\n| `ZRANGE key startIndex stopIndex`    | 根据分数从小到大的排序，返回有序集合的指定成员列表     |\n| `ZREVRANGE key startIndex stopIndex` | 根据分数从大到小的排序，返回有序集合的指定成员列表     |\n| `ZRANK key value`                    | 返回有序集合中指定成员的排名（从小到大的排序索引位置） |\n| `ZREVRANK key value`                 | 返回有序集合中指定成员的排名（从大到小的排序索引位置） |\n| `ZREM key value`                     | 从有序集合中删除指定成员                               |\n| `ZSCORE key value`                   | 返回有序集合中指定成员的分数                           |\n\n#### 应用场景\n\n- 排行榜应用场景，如游戏得分排名\n- 带权重的元素排序，如商品价格排名\n- 实时热门内容排行等\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 12,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T02:59:16.000+00:00",
        "updateTime": "2023-10-24T02:24:08.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it😣😣",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-21T02:01:28.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Redis",
          "SQL"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712659313811648513",
        "title": "RESTFUL-风格完成后端接口开发",
        "description": "REST ",
        "content": "## REST\n\n### REST风格 API接口开发\n\n#### 1. RESTful (核心思想===>表现层状态转换)\n\n1.1 RESTful是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。\n\n1.2 RESTful是目前最流行的一种互联网软件架构。\n\n1.3 RESTful架构的核心原则：\n```text\n1- 以资源为中心，资源是指网络上的一个实体，或者说是网络上的一个具体信息。\n- 每个资源对应一个特定的资源路径，即URI。\n- 客户端和服务器之间，传递这种资源的某种表现层状态，即表现层状态转换。\n\n以资源为基础 ：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，\n除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。\n\n2- 统一接口：统一接口是RESTful架构的基础，只要是符合RESTful架构原则的，都可以称为RESTful接口。\n- 统一接口包括：资源标识、资源操作、自描述消息、超媒体作为应用状态引擎。\n- 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。\n- GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。\n- DELETE（DELETE）：从服务器删除资源\n- 通过统一接口，实现了客户端和服务器的分离，使得客户端不用关心服务器的技术实现，而服务器也不用关心客户端的业务逻辑。\n```\n传统API接口开发和RESTful API接口开发对比：\n\n| 传统API接口开发 | RESTful API接口开发 |\n| :--- | :--- |\n| 以动作为中心 | 以资源为中心 |\n| 以动词为中心 | 以名词为中心 |\n| 以操作为中心 | 以数据为中心 |\n| 以过程为中心 | 以结果为中心 |\n| 以业务为中心 | 以实体为中心 |\n\n![image.png](https://pic.code-nav.cn/post_picture/1673111457186713601/edLHAoeZ-image.png)\n\n#### 2. RESTful URI设计\n1. 不用大写字母，所有单词使用英文且小写。\n2. 连字符用中杠\"-\"而不用下杠\"_\"\n3. 正确使用 \"/\"表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定\n4. 结尾不要包含正斜杠分隔符\"/\"\n5. URL中不出现动词，用请求方式表示动作\n6. 资源表示用复数不要用单数\n7. 不要使用文件扩展名\n8. 用好HTTP状态码\n\n#### 3. RESTful 响应状态码\n使用RESTful风格的API接口开发，一般需要返回响应状态码和响应数据，\n响应状态码的使用非常重要，下面列举了常用的状态码：\n\n```text\n1. 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n2. 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n3. 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n4. 204 NO CONTENT - [DELETE]：用户删除数据成功。\n5. 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n6. 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n7. 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n8. 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n9. 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n10. 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n11. 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n12. 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n```\n\n#### 4.日常开发使用\n\nRestful 只是一种风格和规范,不是一种标准,不一定要让所有接口全部遵循,一般开发中混用.",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 18,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T02:39:34.000+00:00",
        "updateTime": "2023-10-21T07:30:25.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it😣😣",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-21T02:01:28.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "API接口",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1710609924599443458",
        "title": "Spring -MVC",
        "description": null,
        "content": "## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n ```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n    1. 对象: {\"name\": \"张三\", \"age\": 18}\n    2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n    3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```\n\n## SpringMVC\n\n### SpringMVC基本原理\n\n#### MVC思想\n1. 前端发送请求--> 控制器统一处理--->调用模型方法,返回模型数据\n2. 后端把模型数据返还视图(web 中不支持)--->视图--->前端\n3. 控制器也可以选择视图 --->前端\n\n\n#### 为什么使用Spring-MVC\n1. 低耦合,灵活性和扩展性高\n2. 安全,效率高\n3. 与spring 无缝衔接\n### 前端控制器\n#### 有没有的区别\n1. 无:多个用户-->多个请求---> 多个servlet\n2. 有:多个用户-->多个请求---> 一个servlet\n\n\n#### 配置前端控制器\n1. 在 main 目录新建 webapp/WEB-INF/web.xml，内容如下：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n         version=\"3.0\">\n\n    <!-- Spring MVC 前端控制器-->\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <!-- 指定 Spring 容器启动加载的配置文件-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:mvc.xml</param-value>\n        </init-param>\n        <!-- Tomcat 启动初始化 -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n\n2. 创建控制器类\n3. mvc.xml 配置文件\n```xml\n<!-- 配置 IoC DI 注解解析器，让 Spring 我们创建 HelloController 类的对象 -->\n<context:component-scan base-package=\"cn.wolfcode.web.controller\"/>\n\n        <!-- MVC 注解解析器 -->\n<mvc:annotation-driven/>\n```\n\n\n### 常用注解\n#### RequestMapping 注解\n\nRequestMapping 注解是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。还可以限定请求类型和响应类型等。\n\n#### @ResponseBody注解\n\n将方法的返回值转换成json并响应给浏览器\n\n#### MVC 注解解析器\n\n配置了会往容器中存入 RequestMappingHandlerMapping、RequestMappingHandlerAdapter、ExceptionHandlerExceptionResolver 等三个 bean。除此之外：\n- 支持使用 ConversionService 实例对表单参数进行类型转换。\n- 支持使用 @NumberFormat、@DateTimeFormat 注解完成数据格式化操作。\n- 支持使用 @Valid 注解对 JavaBean 实例进行 JSR303 验证。\n- 支持使用 @RequestBody 和 @ResponseBody 注解读写 JSON。\n\n\n### 参数接受\n#### 基本类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 包装类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 数组类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 集合类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 自定义类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 时间类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n```text\n@DateTimeFormat(pattern = \"yyyy-MM-dd\")\n```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 33,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-07T10:56:02.000+00:00",
        "updateTime": "2023-10-19T12:46:55.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it😣😣",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-21T02:01:28.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1710587358686081026",
        "title": "Java -Spring-boot",
        "description": "Springboot 和集成SSm",
        "content": "## Spring-Boot\n\n### 1. Spring-Boot简介\nSpring-Boot是Spring官方提供的一个快速开发脚手架，可以基于Spring-Boot快速开发单个微服务。\n使用目的:简化Spring应用的初始搭建以及开发过程。如配置文件的配置，繁琐的依赖配置等。\n\n### 2. Spring-Boot特点\n1. 独立运行的Spring项目\n2. 内嵌Tomcat、Jetty或Undertow，不需要部署WAR文件\n3. 提供运行时的应用监控\n4. 提供starter简化Maven配置\n5. 自动配置Spring\n\n### 3.AppConfig.java 配置类\n1. @Configuration:声明当前类是一个配置类，相当于Spring配置的xml文件\n2. @Bean:声明在方法上，将方法的返回值加入Bean容器，相当于Spring配置的<bean>标签\n2.1 @Bean(name=\"user\")：指定Bean的名称，如果不指定，Bean的名称默认为方法名\n2.2 @Bean(name=\"user\",initMethod=\"init\",destroyMethod=\"destroy\")：指定Bean的初始化方法和销毁方法\n2.3 关联其他Bean：\n3. @ComponentScan:自动扫描包，相当于Spring配置的<context:component-scan>标签\n```java\n// 方式一： 调用方法注入 关联的bean\n@Bean\npublic User user(){\n    return new User();\n}\n@Bean\npublic UserService userService(){\n    UserService userService = new UserService();\n    userService.setUser(user());\n    return userService;\n}\n\n// 方式二：通过方法形参注入 关联的bean\n@Bean\npublic UserService userService(User user){\n    UserService userService = new UserService();\n    userService.setUser(user);\n    return userService;\n}\n```\n\n### 4.测试类Junit4和Junit5\n```java\n// Junit4\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = AppConfig.class)\n// Junit5\n@SpringBootTest(classes = AppConfig.class)\n```\n\n\n### 5.主配置中导入其他配置类或者配置文件\n```java\n// 方式一：通过@Import注解导入其他配置类\n@Configuration\n@Import({AppConfig2.class,AppConfig3.class})\n\n\n// 方式二：通过@ImportResource注解导入其他配置文件\n@Configuration\n@ImportResource(\"classpath:applicationContext.xml\")\n\n// 方式三：通过@PropertySource注解导入其他配置文件\n@Configuration\n@PropertySource(\"classpath:jdbc.properties\")\n```\n\n### 6.配置文件的优先级\n`properties`文件的优先级高于`yml`文件而以下四个位置的配置文件优先级高低顺序如下：\n1. 项目根目录下的config文件夹\n2. 项目根目录下\n3. classpath下的config文件夹\n4. classpath下\n\n### 7.读取配置文件(三种方式)\n```java\n// 方式一：通过@Value注解读取配置文件\n@Value(\"${name}\")\nprivate String name;\n\n// 方式二：通过Environment读取配置文件\n@Autowired\nprivate Environment env;\nenv.getProperty(\"name\");\n\n// 方式三：通过@ConfigurationProperties注解读取配置文件\n@ConfigurationProperties(prefix = \"user\")\n```\n\n## Spring-Boot 集成ssm\n### 1. Spring-Boot集成Mybatis\n1. 导入依赖\n```xml\n<!-- Spring-Boot集成Mybatis -->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n</dependency>\n```\n2. 配置数据源\n```yml\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: 123456\n```\n3. 配置Mybatis\n```yml\nmybatis:\n  mapper-locations: classpath:mapper/*.xml\n  type-aliases-package: com.example.demo.entity\n```\n4. 编写Mapper接口和Mapper.xml文件\n```java\n// Mapper接口\npublic interface UserMapper {\n    List<User> findAll();\n}\n\n// Mapper.xml文件\n<mapper namespace=\"com.example.demo.mapper.UserMapper\">\n    <select id=\"findAll\" resultType=\"com.example.demo.entity.User\">\n        select * from user\n    </select>\n</mapper>\n```\n5.使用PageHelper分页插件\n```xml\n<!-- 使用PageHelper分页插件 -->\n<dependency>\n    <groupId>com.github.pagehelper</groupId>\n    <artifactId>pagehelper-spring-boot-starter</artifactId>\n</dependency>\n```\n\n### 2. Spring-Boot集成SpringMVC\n1. 导入依赖\n```xml\n<!-- Spring-Boot集成SpringMVC -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n2. 配置SpringMVC\n```java\n// 配置类\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/\").setViewName(\"index\");\n    }\n}\n\n// 静态资源配置\nspring:\n  mvc:\n    static-path-pattern: /static/**\n    static-locations: classpath:/static/\n```\n3. 编写Controller\n```java\n@Controller\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(\"/findAll\")\n    public String findAll(Model model){\n        List<User> users = userService.findAll();\n        model.addAttribute(\"users\",users);\n        return \"userList\";\n    }\n}\n```\n\n### 3. 事务管理\n1. 导入依赖\n```xml\n<!-- 事务管理 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n```\n2. 配置事务管理器\n```java\n// 配置类\n@Configuration\npublic class TransactionConfig {\n    @Autowired\n    private DataSource dataSource;\n\n    @Bean\n    public DataSourceTransactionManager transactionManager(){\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n```\n\n\n### 4.统一异常处理\n1. 编写异常处理类\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(Exception.class)\n    public String exceptionHandler(Exception e, Model model){\n        model.addAttribute(\"msg\",e.getMessage());\n        return \"error\";\n    }\n}\n```\n2. 拦截器配置\n```java\n// 配置类\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\n### 5. 日志管理\n1. Slf4j日志\n2. 使用方式\n```xml\n// 方式一：直接使用\nprivate static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n// 方式二：使用注解\n@Slf4j\n```\n3. 日志级别\n```xml\n# 日志级别\nwarn\ninfo\ndebug\nerror\n```\n4.5、Logback 配置文件的使用\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    scan：开启日志框架的热部署，默认值 true 表示开启\n    scanPeriod：热部署的频率，默认值 60 second\n    debug：设置输出框架内部的日志，默认值 false\n-->\n<configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\">\n    <property name=\"appName\" value=\"springboot demo\" />\n    <contextName>${appName}</contextName>\n    \n    <!-- appender：日志输出对象，配置不同的类拥有不同的功能\n        ch.qos.logback.core.ConsoleAppender：日志输出到控制台        \n    -->\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd-HH：mm：ss} %level [%thread]-%logger{35} >> %msg %n</pattern>\n　　　　　</encoder>\n　　 </appender>\n    \n    <!-- ch.qos.logback.core.FileAppender：日志输出到文件中\n    <appender name=\"fileAppender\" class=\"ch.qos.logback.core.FileAppender\">\n        <encoder>\n            <pattern>%-4relative [%thread] %level %logger{35} - %msg %n</pattern>\n    　　 </encoder>\n        <append>true</append>\n        <file>mylog.log</file>\n　　 </appender>\n    -->\n    \n    <!-- \n        root 是项目通用的 logger，一般情况下都是使用 root 配置的日志输出\n        level：按照级别输出日志，日志级别，级别越高，输出的内容越少\n    -->\n　　 <root level=\"info\">\n        <appender-ref ref=\"STDOUT\" />\n    </root>\n    \n    <!-- 自定义的 logger，用于专门输出特定包中打印的日志\n    <logger name=\"cn.wolfcode.crm.mapper\" level=\"trace\">\n    </logger>\n\t-->\n</configuration>\n```\n\n### 6. 修改banner\n1. 在src/main/resources目录下新建banner.txt文件\n\n### 7. 热部署\n1. 导入依赖\n```xml\n<!-- 热部署 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n2. 配置文件\n```yml\n# 热部署\nspring:\n  devtools:\n    restart:\n      enabled: true\n```\n\n### 8. 自动配置\n    推荐文章:\n    https://blog.csdn.net/qq_41805567/article/details/129111183",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 29,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-07T09:26:22.000+00:00",
        "updateTime": "2023-10-23T15:17:18.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it😣😣",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-21T02:01:28.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Java 基础",
          "Spring"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1709490834266779650",
        "title": "前端构建工具 ：SWC",
        "description": "前端构建工具对比",
        "content": "> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​\t所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/bMD1KmN9-鱼聪明AI绘画.jpeg",
        "language": null,
        "viewNum": 28,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-04T08:49:10.000+00:00",
        "updateTime": "2023-10-20T13:11:39.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 12,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-10-11T01:17:28.000+00:00"
        },
        "tags": [
          "文章",
          "前端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "179",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "23"
  },
  "message": "ok"
}